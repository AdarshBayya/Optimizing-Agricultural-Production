# -*- coding: utf-8 -*-
"""optimization_of_agricultural_production.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qZpmwh5BMydDgGz-s_pD8zLHhkUswWuv

#**Objective of the Proposed Research**

The purpose of this study is to evaluate parameters, such as soil, fertilizers, climate and weather change ,concentration of micro and macro nutrients  may affect farm profitability, particularly in relation to crop output. The quick climatic change and efficient fertilizer application have an impact on soil health.

```
Stakeholder

```
**AMS Corporation**




Our goal in working with AMS corporationÂ is to choose the best crop for cultivation based on seven parameters that are crucial to obtaining the highest crop production and income.


To develop the crop, you must have previous experience, This is an outdated misconception perpetuated by ancient traditions. Over the years, we gathered data from many places with various characteristics. After evaluating the metrics of the data, we developed a tool to help new and experienced farmers cultivate their crops more effectively. The quantity of a certain nutrient to apply and the ideal period to cultivate particular crops are two additional crucial components of a crop advice.

#### Importing the Libraries
"""

# for manipulations
import numpy as np
import pandas as pd

# for data visualizations
import matplotlib.pyplot as plt
import seaborn as sns
plt.style.use('fivethirtyeight')

# for interactivity
import ipywidgets
from ipywidgets import interact
import pickle

import matplotlib.pyplot as plt
from scipy.cluster.hierarchy import dendrogram, linkage, leaves_list

"""#### Reading the Dataset"""

# Examine the data.
data = pd.read_csv('data.csv')

# Examine the dataset's form
print("Shape of the Dataset :", data.shape)

"""#**Data Exploration**:"""

# Examine the dataset's head.
data.head()

"""## Description for each of the columns in the Dataset

N - ratio of Nitrogen content in soil
P - ratio of Phosphorous content in soil
K - ration of Potassium content in soil
temperature - temperature in degree Celsius
humidity - relative humidity in %
ph - ph value of the soil
rainfall - rainfall in mm
"""

# Examine the Crops in this Dataset.
data['label'].value_counts()

#Unique Data
data.nunique()

#Utilized in the dataset were crops
data['label'].unique()

"""#**Data Cleaning**:
#### lets check if there is any missing value present in the dataset
"""

#tracking down empty values
data.isnull().sum()

#summary
crop_summary=pd.pivot_table(data,index=['label'],aggfunc='mean')
crop_summary

"""#**Adaptation**:

#### created three additional columns that are necessary for your study
"""

#finding the median
import statistics
data['Avg K'] = statistics.mean(data['K'])
data['Avg N'] = statistics.mean(data['P'])
data['Avg P'] = statistics.mean(data['N'])
data.head()

"""#**Visualization** :

#**Descriptive Visualization**:
"""

sns.displot(data, x="N", y="K")

g = sns.PairGrid(data)
g.map_upper(sns.histplot)
g.map_lower(sns.kdeplot, fill=True)
g.map_diag(sns.histplot, kde=True)

"""According to the data distribution, there is no association between the various soil restrictions."""

data1=data[['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']]
for i in data1.columns:
    plt.figure(figsize=(15,6))
    sns.boxplot(data1[i])
    plt.xticks(rotation=90)
    plt.show()

"""Based on a five-number summary, the data distribution is described as "minimum," "first quartile [Q1], median, third quartile [Q3], and "maximum."
"""

g = sns.catplot(data=data, x="N", y="label", kind="violin", inner=None)
sns.swarmplot(data=data, x="N", y="label", color="k", size=3, ax=g.ax)

"""Nitrogen distribution for the relevant crops"""

sns.catplot(data=data, x="N", y="label", kind="box")

sns.catplot(data=data, x="temperature", kind="count", palette="ch:.25")

sns.catplot(data=data, x="K", y="label", kind="box")

"""Potassium distribution for the corresponding crops"""

sns.catplot(data=data, x="rainfall", y="label", kind="box")

sns.catplot(data=data, x="ph", y="label", kind="box")

"""Ph distribution in the soil for the various crops"""

sns.catplot(data=data, x="temperature", y="label", kind="box")

"""#**Dendrogram**

Temperature distribution for the relevant crops
"""

#dendrogram(Z)
Z = linkage(Z, 'average')
plt.figure(figsize=(25, 10))
plt.title('Hierarchical Clustering Dendrogram')
dendrogram(Z, leaf_font_size = 32.)
plt.show()

"""**Cluster Analysis**:"""

new_data = data.drop(['label'], axis=1)
from pandas import DataFrame
from sklearn.metrics.pairwise import euclidean_distances
grades_distance_df = DataFrame(euclidean_distances(new_data))
grades_distance_df.astype(int)

Z = linkage(new_data, 'average')
Z
dendrogram(Z)

Z = linkage(new_data, 'average')

plt.figure(figsize=(25, 10))
plt.title('Hierarchical Clustering Dendrogram')
dendrogram(Z, leaf_font_size = 32.)
plt.show()

plt.figure(figsize=(25, 10))
D = dendrogram(Z=Z, orientation="right", leaf_font_size=23,
               labels = new_data.index)

from scipy.cluster.hierarchy import fcluster
k = 5
dend_clusters = fcluster(Z, k, criterion = 'maxclust')
dend_clusters

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 15))
ax = fig.add_subplot(111, projection = '3d')

ax.scatter(xs = new_data.N, ys = new_data.P, zs = new_data.K, c = dend_clusters, cmap='viridis',
           s = 180, edgecolor = 'black', depthshade = True)

for name, P, N, K in new_data[['P', 'N', 'K']].itertuples(index=True, name=None):
    ax.text(P , N , K, name)

ax.set_xlabel('P')
ax.set_ylabel('N')
ax.set_zlabel('K')

plt.show()

X = data.iloc[:, [0,1,2,3, 4,5,6]].values
X

k=data.drop(['label'], axis=1)

Z = linkage(k, 'average')
Z

Z = linkage(Z, 'average')

plt.figure(figsize=(25, 10))
plt.title('Hierarchical Clustering Dendrogram')
dendrogram(Z, leaf_font_size = 32.)
plt.show()

data.head()

X = data.iloc[:, [0,1,2,3, 4,5,6]].values
X

k=data.drop(['label'], axis=1)
#data.drop(['B', 'C'], axis=1)

Z = linkage(k, 'average')
Z

"""#**Descriptive Statistics**"""

# review the Summary for each crop.

print("Average Ratio of Nitrogen in the Soil : {0:.2f}".format(data['N'].mean()))
print("Average Ratio of Phosphorous in the Soil : {0:.2f}".format(data['P'].mean()))
print("Average Ratio of Potassium in the Soil : {0:.2f}".format(data['K'].mean()))
print("Average Tempature in Celsius : {0:.2f}".format(data['temperature'].mean()))
print("Average Relative Humidity in % : {0:.2f}".format(data['humidity'].mean()))
print("Average PH Value of the soil : {0:.2f}".format(data['ph'].mean()))
print("Average Rainfall in mm : {0:.2f}".format(data['rainfall'].mean()))

# Have a look at the Summary Statistics for each of the Crops.

@interact
def summary(crops = list(data['label'].value_counts().index)):
    x = data[data['label'] == crops]
    print("---------------------------------------------")
    print("Statistics for Nitrogen")
    print("Minimum Nitrigen required :", x['N'].min())
    print("Average Nitrogen required :", x['N'].mean())
    print("Maximum Nitrogen required :", x['N'].max())
    print("---------------------------------------------")
    print("Statistics for Phosphorous")
    print("Minimum Phosphorous required :", x['P'].min())
    print("Average Phosphorous required :", x['P'].mean())
    print("Maximum Phosphorous required :", x['P'].max())
    print("---------------------------------------------")
    print("Statistics for Potassium")
    print("Minimum Potassium required :", x['K'].min())
    print("Average Potassium required :", x['K'].mean())
    print("Maximum Potassium required :", x['K'].max())
    print("---------------------------------------------")
    print("Statistics for Temperature")
    print("Minimum Temperature required : {0:.2f}".format(x['temperature'].min()))
    print("Average Temperature required : {0:.2f}".format(x['temperature'].mean()))
    print("Maximum Temperature required : {0:.2f}".format(x['temperature'].max()))
    print("---------------------------------------------")
    print("Statistics for Humidity")
    print("Minimum Humidity required : {0:.2f}".format(x['humidity'].min()))
    print("Average Humidity required : {0:.2f}".format(x['humidity'].mean()))
    print("Maximum Humidity required : {0:.2f}".format(x['humidity'].max()))
    print("---------------------------------------------")
    print("Statistics for PH")
    print("Minimum PH required : {0:.2f}".format(x['ph'].min()))
    print("Average PH required : {0:.2f}".format(x['ph'].mean()))
    print("Maximum PH required : {0:.2f}".format(x['ph'].max()))
    print("---------------------------------------------")
    print("Statistics for Rainfall")
    print("Minimum Rainfall required : {0:.2f}".format(x['rainfall'].min()))
    print("Average Rainfall required : {0:.2f}".format(x['rainfall'].mean()))
    print("Maximum Rainfall required : {0:.2f}".format(x['rainfall'].max()))

## Compare each crop's average need with typical weather conditions.

@interact
def compare(conditions = ['N','P','K','temperature','ph','humidity','rainfall']):
    print("Average Value for", conditions,"is {0:.2f}".format(data[conditions].mean()))
    print("----------------------------------------------")
    print("Rice : {0:.2f}".format(data[(data['label'] == 'rice')][conditions].mean()))
    print("Black Grams : {0:.2f}".format(data[data['label'] == 'blackgram'][conditions].mean()))
    print("Banana : {0:.2f}".format(data[(data['label'] == 'banana')][conditions].mean()))
    print("Jute : {0:.2f}".format(data[data['label'] == 'jute'][conditions].mean()))
    print("Coconut : {0:.2f}".format(data[(data['label'] == 'coconut')][conditions].mean()))
    print("Apple : {0:.2f}".format(data[data['label'] == 'apple'][conditions].mean()))
    print("Papaya : {0:.2f}".format(data[(data['label'] == 'papaya')][conditions].mean()))
    print("Muskmelon : {0:.2f}".format(data[data['label'] == 'muskmelon'][conditions].mean()))
    print("Grapes : {0:.2f}".format(data[(data['label'] == 'grapes')][conditions].mean()))
    print("Watermelon : {0:.2f}".format(data[data['label'] == 'watermelon'][conditions].mean()))
    print("Kidney Beans: {0:.2f}".format(data[(data['label'] == 'kidneybeans')][conditions].mean()))
    print("Mung Beans : {0:.2f}".format(data[data['label'] == 'mungbean'][conditions].mean()))
    print("Oranges : {0:.2f}".format(data[(data['label'] == 'orange')][conditions].mean()))
    print("Chick Peas : {0:.2f}".format(data[data['label'] == 'chickpea'][conditions].mean()))
    print("Lentils : {0:.2f}".format(data[(data['label'] == 'lentil')][conditions].mean()))
    print("Cotton : {0:.2f}".format(data[data['label'] == 'cotton'][conditions].mean()))
    print("Maize : {0:.2f}".format(data[(data['label'] == 'maize')][conditions].mean()))
    print("Moth Beans : {0:.2f}".format(data[data['label'] == 'mothbeans'][conditions].mean()))
    print("Pigeon Peas : {0:.2f}".format(data[(data['label'] == 'pigeonpeas')][conditions].mean()))
    print("Mango : {0:.2f}".format(data[data['label'] == 'mango'][conditions].mean()))
    print("Pomegranate : {0:.2f}".format(data[(data['label'] == 'pomegranate')][conditions].mean()))
    print("Coffee : {0:.2f}".format(data[data['label'] == 'coffee'][conditions].mean()))

# Improve the intuition of this function.

@interact
def compare(conditions = ['N','P','K','temperature','ph','humidity','rainfall']):
    print("Crops which require greater than average", conditions,'\n')
    print(data[data[conditions] > data[conditions].mean()]['label'].unique())
    print("----------------------------------------------")
    print("Crops which require less than average", conditions,'\n')
    print(data[data[conditions] <= data[conditions].mean()]['label'].unique())

"""#**Analyzing Agricultural Conditions**"""

### Look at how agricultural conditions are distributed.

plt.rcParams['figure.figsize'] = (15, 7)

plt.subplot(2, 4, 1)
sns.distplot(data['N'], color = 'lightgrey')
plt.xlabel('Ratio of Nitrogen', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 2)
sns.distplot(data['P'], color = 'skyblue')
plt.xlabel('Ratio of Phosphorous', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 3)
sns.distplot(data['K'], color ='darkblue')
plt.xlabel('Ratio of Potassium', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 4)
sns.distplot(data['temperature'], color = 'black')
plt.xlabel('Temperature', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 5)
sns.distplot(data['rainfall'], color = 'grey')
plt.xlabel('Rainfall', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 6)
sns.distplot(data['humidity'], color = 'lightgreen')
plt.xlabel('Humidity', fontsize = 12)
plt.grid()

plt.subplot(2, 4, 7)
sns.distplot(data['ph'], color = 'darkgreen')
plt.xlabel('pH Level', fontsize = 12)
plt.grid()

plt.suptitle('Distribution for Agricultural Conditions', fontsize = 20)
plt.show()

## Learn some Interesting Facts now.

print("Some Interesting Patterns")
print("---------------------------------")
print("Crops which requires very High Ratio of Nitrogen Content in Soil:", data[data['N'] > 120]['label'].unique())
print("Crops which requires very High Ratio of Phosphorous Content in Soil:", data[data['P'] > 100]['label'].unique())
print("Crops which requires very High Ratio of Potassium Content in Soil:", data[data['K'] > 200]['label'].unique())
print("Crops which requires very High Rainfall:", data[data['rainfall'] > 200]['label'].unique())
print("Crops which requires very Low Temperature :", data[data['temperature'] < 10]['label'].unique())
print("Crops which requires very High Temperature :", data[data['temperature'] > 40]['label'].unique())
print("Crops which requires very Low Humidity:", data[data['humidity'] < 20]['label'].unique())
print("Crops which requires very Low pH:", data[data['ph'] < 4]['label'].unique())
print("Crops which requires very High pH:", data[data['ph'] > 9]['label'].unique())

### Learn which crops may only be grown during the summer, winter, and rainy seasons.

print("Summer Crops")
print(data[(data['temperature'] > 30) & (data['humidity'] > 50)]['label'].unique())
print("-----------------------------------")
print("Winter Crops")
print(data[(data['temperature'] < 20) & (data['humidity'] > 30)]['label'].unique())
print("-----------------------------------")
print("Rainy Crops")
print(data[(data['rainfall'] > 200) & (data['humidity'] > 30)]['label'].unique())

"""#**Clustering Similar Crops**"""

### Try to group these crops together.

# To prevent warnings, import the warnings library.
import warnings
warnings.filterwarnings('ignore')

# Choose the Annual Income and Spending Score columns from the data.
x = data.loc[:, ['N','P','K','temperature','ph','humidity','rainfall']].values

# Examine x's form.
print(x.shape)

# these information into a dataframe
x_data  = pd.DataFrame(x)
x_data.head()

# Calculate the ideal number of clusters for the dataset.

from sklearn.cluster import KMeans
plt.rcParams['figure.figsize'] = (10, 4)

wcss = []
for i in range(1, 11):
    km = KMeans(n_clusters = i, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
    km.fit(x)
    wcss.append(km.inertia_)

# Map the outcomes.
plt.plot(range(1, 11), wcss)
plt.title('The Elbow Method', fontsize = 20)
plt.xlabel('No. of Clusters')
plt.ylabel('wcss')
plt.show()

# Use the K Means technique to do a cluster analysis.
km = KMeans(n_clusters = 4, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
y_means = km.fit_predict(x)

# Examine the outcomes
a = data['label']
y_means = pd.DataFrame(y_means)
z = pd.concat([y_means, a], axis = 1)
z = z.rename(columns = {0: 'cluster'})

# Examine each crop's clusters.
print("Lets check the Results After Applying the K Means Clustering Analysis \n")
print("Crops in First Cluster:", z[z['cluster'] == 0]['label'].unique())
print("---------------------------------------------------------------")
print("Crops in Second Cluster:", z[z['cluster'] == 1]['label'].unique())
print("---------------------------------------------------------------")
print("Crops in Third Cluster:", z[z['cluster'] == 2]['label'].unique())
print("---------------------------------------------------------------")
print("Crops in Forth Cluster:", z[z['cluster'] == 3]['label'].unique())

# Intense Clustering
print("Results for Hard Clustering\n")
counts = z[z['cluster'] == 0]['label'].value_counts()
d = z.loc[z['label'].isin(counts.index[counts >= 50])]
d = d['label'].value_counts()
print("Crops in Cluster 1:", list(d.index))
print("--------------------------------------------------")
counts = z[z['cluster'] == 1]['label'].value_counts()
d = z.loc[z['label'].isin(counts.index[counts >= 50])]
d = d['label'].value_counts()
print("Crops in Cluster 2:", list(d.index))
print("--------------------------------------------------")
counts = z[z['cluster'] == 2]['label'].value_counts()
d = z.loc[z['label'].isin(counts.index[counts >= 50])]
d = d['label'].value_counts()
print("Crops in Cluster 3:", list(d.index))
print("--------------------------------------------------")
counts = z[z['cluster'] == 3]['label'].value_counts()
d = z.loc[z['label'].isin(counts.index[counts >= 50])]
d = d['label'].value_counts()
print("Crops in Cluster 4:", list(d.index))

"""#**Predictive Modelling**"""

# Divide the predictive modeling data set.

y = data['label']
x = data.drop(['label'], axis = 1)

print("Shape of x:", x.shape)
print("Shape of y:", y.shape)

# Build Training and Testing Sets for Results Validation.
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 0)

print("The Shape of x train:", x_train.shape)
print("The Shape of x test:", x_test.shape)
print("The Shape of y train:", y_train.shape)
print("The Shape of y test:", y_test.shape)

# Create a predictive model now.

from sklearn.linear_model import LogisticRegression

model1 = LogisticRegression()
model1.fit(x_train, y_train)
y_pred = model1.predict(x_test)

# Assess the performance of the model.
from sklearn.metrics import classification_report, confusion_matrix

# Firstly, print the Confusion matrix.
plt.rcParams['figure.figsize'] = (10, 10)
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot = True, cmap = 'Wistia')
plt.title('Confusion Matrix for Logistic Regression', fontsize = 15)
plt.show()

# Printing the Classification Report as well
cr = classification_report(y_test, y_pred)
print(cr)

"""#**Real time Predictions**"""

prediction = model1.predict((np.array([[11,
                                       44,
                                       33,
                                       12,
                                       48,
                                       95,
                                       52,
                                       62,
                                       77,
                                       11]])))
print("The Suggested Crop for Given Climatic Condition is :", prediction)

# Check out the orange model
data[data['label'] == 'orange'].head()

"""#**Report/Stakeholder**

***Overall status of the project.***

To develop the crop, you must have previous experience. This is an outdated misconception perpetuated by ancient traditions. <br>

Over the years, we gathered data from many places with various characteristics. After evaluating the metrics of the data, we developed a tool to help new and experienced farmers cultivate their crops more effectively.<br>

The quantity of a certain nutrient to apply and the ideal period to cultivate particular crops are two additional crucial components of a crop advice.

***The benefits and call out the impact/dependencies.***

Increasing agricultural output can have a variety of advantages, such as better quality, lower input costs, and higher yields. The type of crop, the growing environment, and the management techniques used by the farmer are only a few of the variables that affect these advantages.

***The issues and next steps.***

The allocation of resources is primarily involved in the optimization of agricultural production. The key challenge is to maximize output while minimizing manufacturing costs. The effective use of land, water, labor, and other resources can help achieve this.

Utilizing resources effectively is crucial to maximizing agricultural output. However, other elements including the state of the market, the weather, and governmental regulations all have an impact on agricultural productivity. Government regulations, for instance, may have an impact on the cost of inputs and outputs, which may then have an impact on the profitability of production. Crop yields and, thus, the financial viability of production, can be impacted by weather conditions.

***Summary of recent decisions, conversations, and assignments allocated.***

The choice to allocate resources to the agricultural sector in order to generate food and other agricultural goods is known as the agricultural production decision. The demands of the populace are taken into account when the government makes this choice. The choice regarding agricultural output is made to make sure that both the agricultural sector and the populace have access to enough food.

***The team's most recent successes in brief.***
Many things contribute to the team's success, including outstanding pitching, timely hitting, and excellent defense. We have a strong and skilled group that can provide outstanding performances when it counts.

***Status updates every week for simple retrieval.***

Utilizing technology, managerial techniques, and legislative actions can enhance the optimization of agricultural production.
"""

#Story Plot

plt.rcParams['figure.figsize'] = (15, 8)

plt.subplot(2, 4, 1)
sns.barplot(data['N'], data['label'])
plt.ylabel(' ')
plt.xlabel('Ratio of Nitrogen', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 2)
sns.barplot(data['P'], data['label'])
plt.ylabel(' ')
plt.xlabel('Ratio of Phosphorous', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 3)
sns.barplot(data['K'], data['label'])
plt.ylabel(' ')
plt.xlabel('Ratio of Potassium', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 4)
sns.barplot(data['temperature'], data['label'])
plt.ylabel(' ')
plt.xlabel('Temperature', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 5)
sns.barplot(data['humidity'], data['label'])
plt.ylabel(' ')
plt.xlabel('Humidity', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 6)
sns.barplot(data['ph'], data['label'])
plt.ylabel(' ')
plt.xlabel('pH of Soil', fontsize = 10)
plt.yticks(fontsize = 10)

plt.subplot(2, 4, 7)
sns.barplot(data['rainfall'], data['label'])
plt.ylabel(' ')
plt.xlabel('Rainfall', fontsize = 10)
plt.yticks(fontsize = 10)

plt.suptitle('Visualizing the Impact of Different Conditions on Crops', fontsize = 15)
plt.show()

